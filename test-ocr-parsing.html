<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>OCR Parsing Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        textarea { width: 100%; height: 150px; margin: 10px 0; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; }
        .result { background: #f8f9fa; padding: 15px; margin: 10px 0; border: 1px solid #dee2e6; }
        .medication { background: #e7f3ff; padding: 10px; margin: 5px 0; border-left: 4px solid #007bff; }
    </style>
</head>
<body>
    <h1>ğŸ§ª OCR Medication Parsing Test</h1>
    
    <h3>Sample Japanese Medication Text:</h3>
    <textarea id="input">ãƒ­ã‚­ã‚½ãƒ‹ãƒ³éŒ 60mg
æœé£Ÿå¾Œ 1éŒ 
1æ—¥3å›

ã‚¢ãƒ ãƒ­ã‚¸ãƒ”ãƒ³éŒ 5mg  
å¤•é£Ÿå‰ 1éŒ 
æ¯æ—¥

ãƒ“ã‚¿ãƒŸãƒ³B1æ•£
æœæ˜¼å¤• å„1åŒ…
1æ—¥3å›æœç”¨</textarea>

    <button onclick="testParsing()">ğŸ” Test OCR Parsing</button>
    
    <div id="results"></div>

    <script type="module">
        // Copy our improved parsing logic
        const medicationPatterns = [
            // Primary pattern: Japanese medications with suffixes (most reliable)
            /([ã‚¡-ãƒ¾ä¸€-é¾¯\w]+(?:éŒ |ã‚«ãƒ—ã‚»ãƒ«|æ•£å‰¤?|é¡†ç²’|æ¶²å‰¤?|è»Ÿè†|ã‚¯ãƒªãƒ¼ãƒ |ã‚·ãƒ­ãƒƒãƒ—|ç‚¹çœ¼|ç‚¹é¼»|å¸å…¥|è²¼ä»˜|åè–¬|æ³¨å°„|å†…æœæ¶²?)(?:\d+(?:mg|Î¼g|g|ml))?)/g,
            // Brand names with dosage embedded (e.g., "ãƒ­ã‚­ã‚½ãƒ‹ãƒ³60mgéŒ ")  
            /([ã‚¡-ãƒ¾ä¸€-é¾¯]{3,}\d+(?:mg|Î¼g|g|ml)éŒ ?)/g,
            // Well-known medication names (specific list to avoid false positives)
            /(ã‚¢ãƒ ãƒ­ã‚¸ãƒ”ãƒ³|ãƒªã‚·ãƒãƒ—ãƒªãƒ«|ãƒ¡ãƒˆãƒ›ãƒ«ãƒŸãƒ³|ãƒ­ã‚­ã‚½ãƒ—ãƒ­ãƒ•ã‚§ãƒ³|ã‚»ãƒ¬ã‚³ã‚­ã‚·ãƒ–|ã‚¢ã‚¹ãƒ”ãƒªãƒ³|ã‚¤ãƒ–ãƒ—ãƒ­ãƒ•ã‚§ãƒ³|ãƒ‘ãƒ©ã‚»ã‚¿ãƒ¢ãƒ¼ãƒ«)(?:éŒ |æ•£|æ¶²)?/g,
            // English medication names (more specific)
            /([A-Za-z]{4,}(?:tin|cin|ol|ine|ate|ide|pril|sartan|statin))/gi
        ];

        const dosagePatterns = [
            /(\d+(?:\.\d+)?)\s*(?:mg|Î¼g|g|ml|éŒ |ã‚«ãƒ—ã‚»ãƒ«|åŒ…|æ»´|å›åˆ†)/gi,
            /(\d+)\s*(?:éŒ |ã‚«ãƒ—ã‚»ãƒ«|åŒ…|æ»´|ç²’|å›åˆ†)/gi,
            /(\d+\.\d+)\s*(?:mg|g|ml)/gi,
            /(\d+[-~]\d+)\s*(?:éŒ |ã‚«ãƒ—ã‚»ãƒ«|åŒ…)/gi
        ];

        const timePatterns = [
            /(\d{1,2}):(\d{2})/g,
            /(æœé£Ÿå‰|æœé£Ÿå¾Œ|æ˜¼é£Ÿå‰|æ˜¼é£Ÿå¾Œ|å¤•é£Ÿå‰|å¤•é£Ÿå¾Œ|å°±å¯å‰|èµ·åºŠæ™‚)/g,
            /(æœ|æ˜¼|å¤•æ–¹?|å¤œ|å¯ã‚‹å‰|é£Ÿå‰|é£Ÿå¾Œ)/g,
            /(\d+æ™‚(?:\d+åˆ†)?)/g,
            /(æœ[ãƒ»ï½¥]?æ˜¼[ãƒ»ï½¥]?å¤•?|æœ[ãƒ»ï½¥]?å¤•|æ˜¼[ãƒ»ï½¥]?å¤•)/g
        ];

        const frequencyPatterns = [
            // Prioritize numerical frequency patterns first
            /(1æ—¥\d+å›|é€±\d+å›|æœˆ\d+å›)/g,
            // General patterns
            /(æ¯æ—¥|éš”æ—¥|å¿…è¦æ™‚)/g,
            // Meal-based patterns (lower priority)
            /(æ¯é£Ÿå¾Œ|æ¯é£Ÿå‰)/g,
            // English patterns
            /(daily|twice|once|bid|tid|qid)/gi,
            // Time-based frequency
            /(\d+æ™‚é–“æ¯|\d+æ™‚é–“ãŠã)/g,
            // Time period patterns (lowest priority, only if no other frequency found)
            /(æœæ˜¼å¤•|æœå¤•|æœæ˜¼|æ˜¼å¤•)/g
        ];

        function convertJapaneseTimeToTime(japaneseTime) {
            const timeMap = {
                'æœ': '08:00', 'æ˜¼': '12:00', 'å¤•': '18:00', 'å¤•æ–¹': '18:00', 'å¤œ': '20:00',
                'æœé£Ÿå‰': '07:30', 'æœé£Ÿå¾Œ': '08:30', 'æ˜¼é£Ÿå‰': '11:30', 'æ˜¼é£Ÿå¾Œ': '12:30',
                'å¤•é£Ÿå‰': '17:30', 'å¤•é£Ÿå¾Œ': '18:30', 'é£Ÿå‰': '07:30', 'é£Ÿå¾Œ': '08:30',
                'å°±å¯å‰': '22:00', 'å¯ã‚‹å‰': '22:00', 'èµ·åºŠæ™‚': '07:00',
                'æœæ˜¼å¤•': '08:00,12:00,18:00', 'æœå¤•': '08:00,18:00', 'æœæ˜¼': '08:00,12:00', 'æ˜¼å¤•': '12:00,18:00'
            };
            
            const hourMatch = japaneseTime.match(/(\d+)æ™‚(?:(\d+)åˆ†)?/);
            if (hourMatch) {
                const hour = hourMatch[1].padStart(2, '0');
                const minute = (hourMatch[2] || '00').padStart(2, '0');
                return `${hour}:${minute}`;
            }
            
            return timeMap[japaneseTime] || '08:00';
        }

        function parseMedicationFromText(ocrText) {
            const medications = [];
            const lines = ocrText.split('\n').filter(line => line.trim().length > 0);
            
            let currentMedication = {};
            
            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // Skip lines that are clearly not medication names (time/frequency only)
                if (/^(æœ|æ˜¼|å¤•|å¤œ|é£Ÿå‰|é£Ÿå¾Œ|æ¯æ—¥|1æ—¥\d+å›|é€±\d+å›|\d+æ™‚é–“)/.test(trimmedLine) && !currentMedication.name) {
                    continue;
                }
                
                // Try to find medication names - only accept strong matches
                let foundMedication = false;
                for (const pattern of medicationPatterns) {
                    const matches = trimmedLine.match(pattern);
                    if (matches) {
                        const medName = matches[0];
                        
                        // Avoid duplicates by checking if this name is already found
                        if (medications.some(med => med.name === medName) || currentMedication.name === medName) {
                            continue;
                        }
                        
                        // If we already have a medication being processed, save it
                        if (currentMedication.name) {
                            medications.push(createMedicationFromPartial(currentMedication));
                        }
                        
                        currentMedication = {
                            name: medName,
                            dosage: '',
                            frequency: '',
                            time: '',
                            instructions: ''
                        };
                        foundMedication = true;
                        break;
                    }
                }
                
                // Only process attributes if we have a current medication and haven't just found a new one
                if (currentMedication.name && !foundMedication) {
                    // Try to find dosage
                    if (!currentMedication.dosage) {
                        for (const pattern of dosagePatterns) {
                            const matches = trimmedLine.match(pattern);
                            if (matches) {
                                currentMedication.dosage = matches[0];
                                break;
                            }
                        }
                    }
                    
                    // Try to find time
                    if (!currentMedication.time) {
                        for (const pattern of timePatterns) {
                            const matches = trimmedLine.match(pattern);
                            if (matches) {
                                if (pattern.source.includes(':')) {
                                    currentMedication.time = matches[0];
                                } else {
                                    currentMedication.time = convertJapaneseTimeToTime(matches[0]);
                                }
                                break;
                            }
                        }
                    }
                    
                    // Try to find frequency (allow overriding with higher priority patterns)
                    let bestFrequency = currentMedication.frequency || '';
                    let bestPriority = 999;
                    
                    // If we already have a frequency, find its priority
                    if (currentMedication.frequency) {
                        for (let i = 0; i < frequencyPatterns.length; i++) {
                            if (frequencyPatterns[i].test(currentMedication.frequency)) {
                                bestPriority = i;
                                break;
                            }
                        }
                    }
                    
                    // Look for better frequency patterns in current line
                    for (let i = 0; i < frequencyPatterns.length; i++) {
                        const pattern = frequencyPatterns[i];
                        const matches = trimmedLine.match(pattern);
                        if (matches) {
                            console.log(`ğŸ“Š Line "${trimmedLine}" matched pattern ${i}: "${matches[0]}" (current priority: ${bestPriority})`);
                            if (i < bestPriority) {
                                console.log(`â¬†ï¸ Upgrading frequency from "${currentMedication.frequency}" to "${matches[0]}"`);
                                bestFrequency = matches[0];
                                bestPriority = i;
                            }
                        }
                    }
                    
                    if (bestFrequency && bestFrequency !== currentMedication.frequency) {
                        console.log(`âœ… Setting frequency to: "${bestFrequency}"`);
                        currentMedication.frequency = bestFrequency;
                    }
                    
                    // Collect instructions (only if we don't have other attributes)
                    if (!currentMedication.instructions && !currentMedication.dosage && !currentMedication.time && !currentMedication.frequency) {
                        currentMedication.instructions = trimmedLine;
                    }
                }
            }
            
            // Add the last medication if exists
            if (currentMedication.name) {
                medications.push(createMedicationFromPartial(currentMedication));
            }
            
            return medications;
        }

        function createMedicationFromPartial(partial) {
            return {
                name: partial.name || 'ä¸æ˜ãªè–¬',
                dosage: partial.dosage || '1éŒ ',
                frequency: partial.frequency || '1æ—¥1å›',
                time: partial.time || '08:00',
                instructions: partial.instructions || 'åŒ»å¸«ã®æŒ‡ç¤ºã«å¾“ã£ã¦ãã ã•ã„'
            };
        }

        window.testParsing = function() {
            const input = document.getElementById('input').value;
            console.log('ğŸ§ª Input text:', input);
            const results = parseMedicationFromText(input);
            
            let html = `<h3>âœ… Found ${results.length} medications:</h3>`;
            
            results.forEach((med, index) => {
                console.log(`ğŸ” Medication ${index + 1}:`, med);
                html += `
                    <div class="medication">
                        <h4>ğŸ’Š ${med.name}</h4>
                        <p><strong>ç”¨é‡:</strong> ${med.dosage}</p>
                        <p><strong>é »åº¦:</strong> ${med.frequency}</p>
                        <p><strong>æ™‚é–“:</strong> ${med.time}</p>
                        <p><strong>æŒ‡ç¤º:</strong> ${med.instructions}</p>
                    </div>
                `;
            });
            
            document.getElementById('results').innerHTML = html;
            console.log('ğŸ¯ Final results:', results);
        }
    </script>
</body>
</html>